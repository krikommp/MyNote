PlayerMode 模式：
RepaintController::RenderPlayModeViewCameras
GetRenderManager().RenderCameras()
// 这里会根据 SRP 是否开启决定渲染方式
if (!RenderCamerasWithScriptableRenderLoop(display)) {
// do something....
// 内置渲染管线
DoRenderScreenCamera(camera, preImageEffectsPerCameraCall, postImageEffectsPerCameraCall);

}

RenderManager::RenderCamerasWithScriptableRenderLoop() {
	if (!ScriptableRenderContext::ShouldUseRenderPipeline())
		return false;
	dynamic_array<Camera*> cameras(kMemTempAlloc);
	FillValidSRPCamerasFromSource(cameras, GetOnscreenCameras(), displayId);

	RendererScene& scene = GetRendererScene();
	scene.BeginCameraRender();
	ScriptableRenderContext renderContext;
	renderContext.ExtractAndExecuteRenderPipeline(cameras);
	scene.EndCameraRender();

	return true;
}

DoRenderScreenCamera(...) {
	if (cam->GetStereoEnable()) {
		// VR 相关
	}else {
		// Regular rendering path: cull, then render
		CullResult cullResult;
		if (cam->GetEnable()) {
			cam->Culling(cullResult);
		}
		if (cam->GetEnable()) {
			cam->UpdateVelocity();
			cam->Render(cullResults, GetDefaultPassContext(), Camera::kRenderFlagSetRenderTarget, preImageEffectsPerCameraCall, postImageEffectsPerCameraCall);
		}
	}
} 

Camera::Cull() {
	// do something....
	CustomCull(...);
}

Camera::CustomCull(...) {
	ITerrainManager* terrianManager = GetITerrianManager();
	if (terrainManager != NULL && cullingCameraParameters.cullingMask != 0) {
		results.terrainCullData = terrainManager->CullAllTerrains(cullingCameraParameters);
	}
}

// 地形渲染路径
TerrainManager::CullAllTerrains() {
	// ....
}




EditorMode 模式：
Camera::RenderEditorCamera(...) {
	if (GetCameraType() == VR && GetStereoEnabled()) {
		// do somethings
		// 可能是和VR设备有关的渲染设置
	}else {
		// 普通模式下相机渲染路径
		RenderEditorCamera();
	}
} 

Camera::RenderEditorCamera(...) {
	// 判断是否使用C++内置渲染管线
	// 如果配置了可编程渲染管线，那么将会调用 C# 层的 `DoRenderLoop_Internal` 函数 进入可编程管线的渲染流程
	const bool useCustomPipeline = ExecuteCustomRenderPipeline(drawMode, gridParam, renderFlags);
	if (useCustomPipeline ) {
		GetRendererScene().EndCameraRender();
	}else {
		cullingCamera->CustomCull(...);	
	}
}

Camera::CustomCull(...) {
	ITerrainManager* terrianManager = GetITerrianManager();
	if (terrainManager != NULL && cullingCameraParameters.cullingMask != 0) {
		results.terrainCullData = terrainManager->CullAllTerrains(cullingCameraParameters);
	}
}

// 地形渲染路径
TerrainManager::CullAllTerrains() {
	// ....
}

-- SRP 渲染地形
1. 为 Terrain 附上材质

// 内部函数调用，当点击更换地形材质时触发
// TerrainBindings.gen.cpp ---- Line 1614
Terrain_Set_Custom_PropMaterialTemplate(...) 
	// Terrain.cpp --- Line 313
	->SetMaterialTemplate(...)
	{
		// 更新材质信息
		UpdateSplatDatabaseUserRegistration();
		{
			// 省略部分
			m_SplatMaterials->ResetVersions();
			// 将旧的材质从 m_SplatMaterialDataUsers 队列中删除
			terrainData->GetSplatDatabase().UnregisterSplatMaterialData(m_RegisteredMaterial);
			// 更新新的材质到 m_SplatMaterialDataUsers  
			terrainData->GetSplatDatabase().RegisterSplatMaterialData(material);
			{
				// SplatDatabase.cpp --- Line 107
				// 省略...
				// 将新的 Material 加入到 m_SplatMaterialDataUsers，并进行一些初始化操作，例如计算引用次数
				dynamic_array<const TerrainLayer*> terrainLayerPtrs(m_TerrainLayers.size(), kMemTempAlloc);
				for (size_t i = 0, n = m_TerrainLayers.size(); i < n; ++i)
					terrainLayerPtrs[i] = m_TerrainLayers[i];
				dynamic_array<Texture*> alphaTexturePtrs(m_AlphaTextures.size(), kMemTempAlloc);
				for (size_t i = 0, n = m_AlphaTextures.size(); i < n; ++i)
					alphaTexturePtrs[i] = m_AlphaTextures[i];
				Vector2f terrainSize(m_TerrainData->GetHeightmap().GetSize().x, m_TerrainData->GetHeightmap().GetSize().z);

				// 计算新 SplatShader 属性
				
				user.materialData.InitializeWithSplatShaders(SplatShaderSet(material));
				{
					1. SplatShaderSet(material) 
					{
						// SplatMaterialData.cpp --- Line 30
						// SplatShaderSet 初始化会根据 Shader 的 Dependency 属性，获取 SplatShaderPass
						// 对于Nature/TerrainLit 会拥有 AddPass 通道，支持多层级
						Shader* shader = material != NULL ? material->GetShader() : NULL;
						(*this)[kSplatShaderFirstPass] = shader != NULL ? shader : Shader::GetDefault();
						(*this)[kSplatShaderAddPass] = shader != NULL ? shader->GetDependency("AddPassShader") : NULL;
						(*this)[kSplatShaderBaseMap] = shader != NULL ? shader->GetDependency("BaseMapShader") : Shader::GetDefault();
						(*this)[kSplatShaderBaseMapGen] = ::FindBaseMapGenShader(shader);
						// 计算每个 pass 支持的 Splat 层级数量
						// 可以在 Tags 中写明 SplatCount 标签即 需要的 Splat 数量，建议为 SplatStaticVars::kSplatsPerControl(4) 的整数倍
						splatsPerPass = GetSplatCountFromTag(shader != NULL ? shader->GetShaderLabShader()->GetTag(GetSplatStaticVars().kTagIDSplatCount, false) : ShaderTagID::Invalid(), shader);
					}
					{
						
					}
				}
			}
			m_RegisteredMaterial = material;
		}
	}

2. 创建 SplatAlpha Texture
// 当创建一层 TerrainLayer 时会调用该方法
// TerrainDataScriptingInterface.cpp	---	Line 344
TerrainDataScriptingInterface::SetTerrainLayersRegisterUndo(...)
	// SplatDatabase.cpp	---	Line 593
	-> SplatDatabase::SetTerrainLayersRegisterUndo(...)
		// 会根据当前的 TerrainLayer 层数创建
		// 判断条件是：将当前层数与 SplatStaticVars::kSplatsPerControl(4) 进行计算，每多4层就会需要多一张 AlphaMap
		// 会保证 m_AlphaTextures 与实际需要的 AlphaMap 数量一致，不足的将进行创建，多余的会被删除
		-> SplatDatabase::ResizeAlphaTextureArray(...)


3. 绘制地形贴图
// 由 c# 端完成地形贴图绘制流程
// C++ 端只需要在每次update更新传递过去的texture信息就可以
	1. 绘制
		绘制开始：
		// TerrainPaintUnitility.cs	---	Line 222
		public static PaintContext BeginPaintTexture(...) {
			// 进行一些绘制的初始化操作，会从 Alphamap 中拿到一张 sourceTexture 作为输入数据
			// 创建本次绘制需要的 sourceTexture 以及 destinationTexture
			PaintContext ctx = InitializePaintContext(...);
			ctx.GatherAlphamap(...);
			return ctx;
		}

		// 


		绘制进行中：
		需要用到的 PaintHeight.shader，这个 shader 用来根据传递过来的画刷信息绘制出一张画板图
		// PaintTextureTool.cs	---	Line 44
		public override bool OnPaint(Terrain terrain, IOnPaint editContext) {
			// 绘制函数 省略部分 ...
			// 计算画刷属性，并将这些属性写入材质中
			// sourceRenderTexture 是画刷自带的画笔贴图，可以从中获取到不同画刷的权重值
			// destinationRenderTexture 是最终根据画刷大小，强度等信息计算出来的实际权重值贴图(最大值不会超过1.0)
			Graphics.Blit(paintContext.sourceRenderTexture, paintContext.destinationRenderTexture, mat, (int)TerrainBuiltinPaintMaterialPasses.PaintTexture);
			// 计算出这张贴图后，会进入到后续绘制过程
			TerrainPaintUtility.EndPaintTexture(paintContext, "Terrain Paint - Texture");
			return true;
		}
		
		// PaintContext.cs		---	Line 536
		public void ScatterAlphamap(string editorUndoName) {
			// 获取 SplatTexture, 根据画刷的 Texture, 绘制出混合后的权重图	
			// 通道遮罩，不同的 Terrain Layer 将会渲染到不同的通道上
			Vector4[] layerMasks = { new Vector(1, 0, 0, 0), new Vector(0, 1, 0, 1), new Vector(0, 0, 1, 0), new Vector(0, 0, 0, 1) };	
			// 省略...
			// 创建了一个临时 Texture, 作为接下来渲染的 RenderTarget
			SatterInternal(t => {
				// ...
				// 地形 SplatTexture 索引值
				// 通过计算获取，根据当前绘制的层数，得到需要在哪张Alphamap上绘制
				int targetAlphamapIndex = userData.mapIndex;
				// 需要渲染到的通道索引
				int targetChannelIndex =userData.channelIndex; 
				// ...
				// 遍历所有的 alphamaps 并进行修改
				for (int i = 0; i < t.terrain.terrainData.alphamapTextureCount; i++) {
					
				}
			});
		}

4. 每帧更新地形数据

ScriptableRenderContext_CUSTOM_Internal_Cull_Injected(...) 函数作为Cull入口
CullScriptable()
	-> CullResults.terrainCullData = terrrainManager->CullAllTerrrains(cullingParameters)
	{
		// 省略...
		// 遍历所有活动的Terrain
		for (TerrainList::const_iterator i = m_ActiveTerrains.begin(); i != m_ActiveTerrains.end(); ++i) {
			// ...
			// 根据透视模式，遍历地形四叉树，计算每个子节点的可视情况
			// 即如果该子节点具有足够的lod，那么其下的所有孩子节点都具有可见性
			// 否则继续遍历该子节点下的节点
			cameraData->terrain->RenderStep1(...);
		}
		// ...
		for (core::flat_set<TerrainData*>::const_iterator it = terrainDatas.begin(); it != terrainDatas.end(); ++it)
			// 更新SplatMaterial信息
			(*it)->GetSplatDatabase().UpdateRegisteredSplatMaterialDatas(updateCache);
			{
				// UpdateRegisteredSplatMaterialDatas 函数
				// 省略部分， TODO...
				bool doUpdate = shaderChanged || materialChanged || updateInputParamsChanged;
				if (doUpdate) {	
					// 一般当新增/删除 Layer 时，会调用该函数
					// 用来更新 SplatMaterial Properties
					user.materialData.Update(material, terrainLayerPtrs, alphaTexturePtrs, terrainSize)
				}
				// 是否需要重新生成 BaseMap 信息
				// 当 PaintTexture 时，会重新生成
				user.materialData.UpdateBaseMaps(material, m_BaseMapResolution, doUpdate || colorSpaceChanged || user.baseMapDirty);
				{
					for (size_t i = 0; !regenerate && i < baseMapCount; ++i)
       						regenerate = regenerate || baseMaps[i].texture == NULL || !baseMaps[i].texture->IsCreated();
					// 如果不需要重新生成就不执行下面的逻辑
					if (!regenerate) return;
					// ...
					
				}
			}
		
	}
