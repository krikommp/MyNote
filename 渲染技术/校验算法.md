# 1. 几种校验算法

## 1.1 奇偶校验
根据数据位中出现 1 的个数来确定校验位是否为 1 或者 0

### 算法实现
> 原始数据 + 1 位检验位

分为奇校验和偶校验两种

对于奇校验，如果原始数据中 1 的个数为奇数，那么就在检验位中填充 0，否则填充 1

对于偶校验，如果原始数据中 1 的个数为奇数，那么就在校验位中填充 1，否则填充 0

### 优缺点
> 优点：其算法简单，对资源消耗较小，易于对数据进行最基础的校验，常用于在硬件中实现

> 缺点：对于数据错位较多的情况下，奇偶校验不一定能检测到错误；且无法定位数据错误的位置；需要为数据添加额外的校验位，无法做到全0数据

### 改进
使用双向奇偶校验，即二维角度上的奇偶校验，可以检测到更多的错误
该检验的对象是一个数据块
```powershell
1001010+1
1011100+0
0100100+0
0011101+0
0101100+1
1011111+0
0111000+1
    +
1100100 1
```
对于以上的数据块，首先对每一列数据进行偶校验，计算得出各自的校验位  
然后再对纵向的数据进行偶检验，得出第八位数据，并且注意到第八位数据的检验位不仅是该数据的校验同时也是前七位数据校验位的校验  
大大降低了数据传输时可能会发生的错误

## 1.2 纵向冗余校验 LRC
### 算法实现
采用了奇偶校验相同的思路，但不是对于一条数据而是数据块，对数据块的纵向进行计算
```powershell
10010101
10111000
01001000
00111010
01011001
10111110
01110001
    +
11001001
```
将每一列的字节从头开始进行异或运算，得出最后一条数据数据作为校验
### 优缺点
> 优点：相比于奇偶校验，LRC需要的资源更少，因为可以对更大比例的数据进行校验计算

> 缺点：与奇偶检验一样，对于数据发生了多重错误，LRC 无法验证。

## 1.3 循环冗余校验 CRC
CRC 校验主要针对的是数据块而非数据位，通过多项式对整个数据进行除法计算。
### 算法实现
基于模二除法，根据约定，存在一个生成多项式 G(x), 这个式子可以由标准中获取（CRC32）。然后将多项式转为二进制编码后，将其长度减去一，得到 CRC 的长度 R。
减去一是因为 CRC 的最高位是 1，不需要存储，所以只需要存储 R 位即可。
然后将数据块左移 R 位，然后与 G(x) 进行模二除法，直到余数位小于或等于 R。
最后将余数前置补 0，得到 R 位的校验码。
### 优缺点
> 优点：在实际的运算中 CRC 基本很难出现验证正确而数据发生错误的情况。
> 并且不同位数发生错误计算出来的结果都是不一样的，所以比较容易定位错误的位置。

> 缺点：无法防止人为修改数据和效验码，因为 CRC 是线性运算，所以很容易通过逆运算获取多项式。

## 1.4 整数加法校验和
### 算法实现
该算法较为简单，直接将数据中的所有书记相加，得到一个字节的校验和。
### 优缺点
> 优点：简单易行，对于数据的校验有一定的效果，并且容易并行

> 缺点：无法定位错误码的位置，并且由于进位的关系，当错误码被进位到忽略的位置上时，无法检测到错误

## 1.5 md5 校验
本质上是一种信息摘要算法，对任意长的信息进行摘要，计算得到一个固定 128 位的数据，防碰撞能力强，适合校验和防止数据篡改的地方。